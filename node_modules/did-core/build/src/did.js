"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Did = exports.PREFIX_FRAGMENT = exports.PREFIX_QUERY = exports.PREFIX_PATH = void 0;
const schemas_1 = require("./schemas");
exports.PREFIX_PATH = '/';
exports.PREFIX_QUERY = '?';
exports.PREFIX_FRAGMENT = '#';
const DEFAULT_PARAMETER_KEYS = [
    'service',
    'relativeRef',
    'versionId',
    'versionTime',
    'hl'
];
class Did {
    constructor(did, parameterKeys) {
        const parsedDid = schemas_1.didUrlSchemaWithouttransformation.parse(did);
        const url = new URL(parsedDid);
        const prefixPathIndex = url.pathname.indexOf(exports.PREFIX_PATH);
        const stripUntil = Math.min(...[
            did.indexOf(exports.PREFIX_PATH),
            did.indexOf(exports.PREFIX_QUERY),
            did.indexOf(exports.PREFIX_FRAGMENT)
        ].filter((i) => i !== -1));
        const didBase = stripUntil !== -1 ? did.slice(0, stripUntil) : did;
        const path = (prefixPathIndex !== -1 ? url.pathname.slice(prefixPathIndex) : '').substring(1);
        const query = url.search.substring(1);
        const queryParams = new URLSearchParams(query);
        const fragment = url.hash.substring(1);
        this.parameterKeys = parameterKeys
            ? [...DEFAULT_PARAMETER_KEYS, ...parameterKeys]
            : DEFAULT_PARAMETER_KEYS;
        this.did = didBase;
        this.path = path.length > 0 ? path : undefined;
        this.query =
            queryParams.size > 0
                ? [...queryParams.entries()].reduce((prev, [k, v]) => (Object.assign({ [k]: v }, prev)), {})
                : undefined;
        this.fragment = fragment.length > 0 ? fragment : undefined;
        this.parameters = this.query
            ? Object.entries(this.query).reduce((prev, [k, v]) => {
                var _a;
                if ((_a = this.parameterKeys) === null || _a === void 0 ? void 0 : _a.includes(k)) {
                    return Object.assign({ [k]: v }, prev);
                }
                return prev;
            }, {})
            : undefined;
    }
    isDidUrl() {
        return Boolean(this.path || this.query || this.fragment);
    }
    static validateDid(did) {
        return schemas_1.stringOrDid.safeParse(did).success;
    }
    static validateDidUrl(did) {
        return schemas_1.stringOrDidUrl.safeParse(did).success;
    }
    validate() {
        if (this.isDidUrl()) {
            return Did.validateDidUrl(this.didUrl);
        }
        else {
            return Did.validateDid(this.did);
        }
    }
    get didUrl() {
        const path = this.path ? `${exports.PREFIX_PATH}${this.path}` : '';
        const queryString = new URLSearchParams(this.query).toString();
        const query = this.query ? `${exports.PREFIX_QUERY}${queryString}` : '';
        const fragment = this.fragment
            ? `${exports.PREFIX_FRAGMENT}${this.fragment}`
            : '';
        return `${this.did}${path}${query}${fragment}`;
    }
    withPath(path) {
        this.path = this.stripOptionalPrefix(path, exports.PREFIX_PATH);
        return this;
    }
    addPath(path) {
        if (this.path) {
            this.path =
                this.path + this.addPrefixIfNotSupplied(path, exports.PREFIX_PATH);
        }
        else {
            return this.withPath(path);
        }
        return this;
    }
    removePath() {
        this.path = undefined;
        return this;
    }
    withQuery(query) {
        this.query = query;
        return this;
    }
    addQuery(query) {
        if (this.query) {
            this.query = Object.assign(Object.assign({}, this.query), query);
        }
        else {
            this.withQuery(query);
        }
        return this;
    }
    removeQuery() {
        this.query = undefined;
        return this;
    }
    withFragment(fragment) {
        this.fragment = this.stripOptionalPrefix(fragment, exports.PREFIX_FRAGMENT);
        return this;
    }
    removeFragment() {
        this.fragment = undefined;
        return this;
    }
    get didParts() {
        const parts = this.did.split(':');
        const scheme = parts[0];
        const method = parts[1];
        const identifier = parts[parts.length - 1];
        const namespaces = parts.slice(2, parts.length - 1);
        return {
            scheme,
            method,
            identifier,
            namespaces: namespaces.length > 0 ? namespaces : undefined
        };
    }
    get didUrlParts() {
        // This is done because the params are calculated based on the query and parameterKeys, but is you set additional parameter keys later on the new parameter field is not updated
        const newDid = new Did(this.didUrl, this.parameterKeys);
        return {
            fragment: newDid.fragment,
            path: newDid.path,
            query: newDid.query,
            parameters: newDid.parameters
        };
    }
    stripOptionalPrefix(s, p) {
        if (s.startsWith(p)) {
            return s.slice(1);
        }
        return s;
    }
    addPrefixIfNotSupplied(s, p) {
        if (s.startsWith(p)) {
            return s;
        }
        return `${p}${s}`;
    }
    addParameterKey(key) {
        if (typeof key === 'string') {
            this.parameterKeys.push(key);
        }
        else if (Array.isArray(key)) {
            this.parameterKeys.push(...key);
        }
        return this;
    }
    toString() {
        return this.didUrl;
    }
    toJSON() {
        return this.toString();
    }
}
exports.Did = Did;
//# sourceMappingURL=did.js.map