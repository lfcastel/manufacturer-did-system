"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uniqueStringOrVerificationMethodsSchema = exports.stringOrVerificationMethod = exports.uniqueVerificationMethodsSchema = exports.verificationMethodSchema = void 0;
const zod_1 = require("zod");
const didSchema_1 = require("./didSchema");
const publicKeyJwkSchema_1 = require("./publicKeyJwkSchema");
const publicKeyMultibaseSchema_1 = require("./publicKeyMultibaseSchema");
const publicKeyJwk_1 = require("../publicKeyJwk");
const publicKeyMultibase_1 = require("../publicKeyMultibase");
const verificationMethod_1 = require("../verificationMethod");
const did_1 = require("../did");
exports.verificationMethodSchema = zod_1.z
    .union([
    zod_1.z.object({
        id: didSchema_1.stringOrDidUrl,
        controller: didSchema_1.stringOrDid,
        type: zod_1.z.string(),
        publicKeyJwk: zod_1.z.optional(publicKeyJwkSchema_1.publicKeyJwkSchema),
        publicKeyMultibase: zod_1.z.optional(publicKeyMultibaseSchema_1.publicKeyMultibaseSchema)
    }),
    zod_1.z.custom((verificationMethod) => verificationMethod instanceof verificationMethod_1.VerificationMethod)
])
    .superRefine((data, ctx) => {
    if (data.publicKeyJwk && data.publicKeyMultibase) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            path: ['publicKeyJwk & publicKeyMultibase'],
            message: 'Supplying both publicKeyJwk and publicKeyMultibase is not permitted'
        });
    }
})
    .transform((verificationMethod) => ({
    id: verificationMethod.id,
    type: verificationMethod.type,
    controller: verificationMethod.controller,
    publicKeyJwk: verificationMethod.publicKeyJwk
        ? verificationMethod.publicKeyJwk instanceof publicKeyJwk_1.PublicKeyJwk
            ? verificationMethod.publicKeyJwk
            : new publicKeyJwk_1.PublicKeyJwk(verificationMethod.publicKeyJwk)
        : undefined,
    publicKeyMultibase: verificationMethod.publicKeyMultibase
        ? verificationMethod.publicKeyMultibase instanceof
            publicKeyMultibase_1.PublicKeyMultibase
            ? verificationMethod.publicKeyMultibase
            : new publicKeyMultibase_1.PublicKeyMultibase(verificationMethod.publicKeyMultibase)
        : undefined
}));
exports.uniqueVerificationMethodsSchema = zod_1.z
    .array(exports.verificationMethodSchema)
    .refine((verificationMethods) => {
    const idSet = new Set();
    for (const obj of verificationMethods) {
        if (idSet.has(obj.id)) {
            return false;
        }
        idSet.add(obj.id);
    }
    return true;
}, `Duplicate verificationMethod.id found. They must be unique`);
exports.stringOrVerificationMethod = zod_1.z
    .union([didSchema_1.stringOrDidUrl, exports.verificationMethodSchema])
    .transform((verificationMethod) => {
    if (verificationMethod instanceof did_1.Did) {
        return verificationMethod;
    }
    return new verificationMethod_1.VerificationMethod(verificationMethod);
});
const uniqueStringOrVerificationMethodsSchema = (name) => zod_1.z.array(exports.stringOrVerificationMethod).refine((verificationMethods) => {
    const idSet = new Set();
    for (const obj of verificationMethods) {
        const id = obj instanceof did_1.Did ? obj.didUrl : obj.id.didUrl;
        if (idSet.has(id)) {
            return false;
        }
        idSet.add(id);
    }
    return true;
}, `Duplicate ${name}.id found. They must be unique`);
exports.uniqueStringOrVerificationMethodsSchema = uniqueStringOrVerificationMethodsSchema;
//# sourceMappingURL=verificationMethodSchema.js.map